<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OPL2 – Lecteur PDN (FEN + variantes + annotations)</title>

  <style>
    :root{
      --panel:#f3efe6;
      --border:#d8cfbf;
      --light:#efe4cf;
      --dark:#a8743a;
      --ink:#2b2b2b;
      --muted:#6b3f2c;
      --w: 520px;
    }

    html,body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--ink)}
    body{
      background:#fff;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:12px;
    }

    .wrap{
      width:var(--w);
      max-width:var(--w);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .topbar{display:flex; gap:10px; align-items:center}
    .selectWrap{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
      width:100%;
      min-width:0;
    }
    .selectWrap strong{white-space:nowrap}
    select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-size:13px;
      outline:none;
      min-width:0;
    }

    .board{
      width:100%;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(10,1fr);
      grid-template-rows:repeat(10,1fr);
      outline:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      box-shadow:0 8px 30px rgba(0,0,0,.20);
      background:#000;
    }

    .sq{position:relative; display:flex; align-items:center; justify-content:center}
    .light{background:var(--light)}
    .dark{background:var(--dark)}

    .num{
      position:absolute; top:3px; left:5px;
      font-size:12px; opacity:.55; color:#000;
      user-select:none; pointer-events:none;
    }
    .dark .num{color:#fff; opacity:.65}

    .piece{
      width:72%;
      aspect-ratio:1/1;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: inset 0 3px 0 rgba(255,255,255,.18), 0 6px 12px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.35);
    }
    .w{background:#f6f1e8}
    .b{background:#1a1a1a}
    .king::after{
      content:"K";
      font-weight:800;
      font-size:18px;
      color:rgba(255,255,255,.85);
      text-shadow:0 1px 0 rgba(0,0,0,.6);
    }
    .w.king::after{color:rgba(0,0,0,.75); text-shadow:none}

    .bar{
      display:flex; gap:6px; align-items:center; justify-content:center;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      flex-wrap:wrap;
    }
    button{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #cdbfa9;
      background:#fff;
      cursor:pointer;
      font-weight:800;
      min-width:44px;
      font-size:14px;
      line-height:1;
    }
    button:disabled{opacity:.55; cursor:not-allowed}

    .info{
      flex:1;
      text-align:center;
      font-size:12px;
      color:var(--muted);
      user-select:none;
      padding:0 8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    .panels{display:grid; grid-template-columns:1fr; gap:10px}
    .panel{
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      box-shadow:0 4px 14px rgba(0,0,0,.08);
    }
    .panel h3{margin:0 0 8px 0; font-size:13px; color:var(--muted)}
    .commentMeta{font-size:12px; color:var(--muted); opacity:.9; margin:0 0 6px 0}
    .commentBox{font-size:13px; line-height:1.35; white-space:pre-wrap; word-break:break-word}

    .varsHeader{display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .crumb{
      font-size:12px; color:var(--muted); opacity:.95;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100%;
    }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:var(--panel);
      border:1px solid var(--border);
      font-size:11px;
      color:var(--muted);
      font-weight:800;
    }
    .varList{display:flex; flex-direction:column; gap:6px}
    .varBtn{
      width:100%;
      text-align:left;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fafafa;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      line-height:1.2;
      color:#2b2b2b;
    }
    .varBtn small{
      display:block;
      font-weight:600;
      color:var(--muted);
      opacity:.9;
      margin-top:2px;
    }
    .varBtn:hover{background:#fff}

    .msg{
      color:#b00020;
      font-family:ui-monospace,Consolas,monospace;
      font-size:12px;
      text-align:center;
      opacity:.95;
      min-height:16px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="selectWrap">
        <strong>Partie</strong>
        <select id="gameSel" aria-label="Sélection de la partie">
          <option value="1">En attente…</option>
        </select>
      </div>
    </div>

    <div id="board" class="board" aria-label="Damier"></div>

    <div class="bar">
      <button id="first" title="Début">⏮</button>
      <button id="prev"  title="Demi-temps précédent">⟵</button>
      <button id="play"  title="Lecture / Pause">▶︎</button>
      <button id="next"  title="Demi-temps suivant">⟶</button>
      <button id="last"  title="Fin">⏭</button>

      <button id="backBranch" title="Retour au point de branchement">↩</button>
      <button id="backMain"   title="Retour à la ligne principale">⇦</button>

      <div id="info" class="info">En attente…</div>
    </div>

    <div class="panels">
      <div class="panel">
        <h3>Commentaire</h3>
        <div id="commentMeta" class="commentMeta"></div>
        <div id="commentBox" class="commentBox">—</div>
      </div>

      <div class="panel">
        <div class="varsHeader">
          <h3 style="margin:0;">Variantes</h3>
          <div id="crumb" class="crumb"></div>
        </div>
        <div id="varList" class="varList" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="msg" class="msg"></div>
  </div>

  <!-- Optionnel : PDN embarqué dans l’iframe
       <script type="text/plain" id="opl-pdn"> ... </script>
       Appel : OPL2.html?src=opl-pdn#111
  -->

<script>
(() => {
  // ============================================================
  //  Helpers cases
  // ============================================================
  function rcFromN(n){
    const i=n-1, r=Math.floor(i/5), k=i%5;
    const c=(r%2===0)?(1+2*k):(0+2*k);
    return [r,c];
  }
  function nFromRC(r,c){
    if ((r+c)%2===0) return null;
    const k=(r%2===0)?(c-1)/2:c/2;
    if (!Number.isInteger(k) || k<0 || k>4) return null;
    return r*5+k+1;
  }
  function inside(r,c){ return r>=0&&r<10&&c>=0&&c<10; }

  // ============================================================
  //  Board model
  // ============================================================
  const pieces=new Map();
  function promoteIfNeeded(n){
    const p=pieces.get(n);
    if (!p || p.king) return;
    const [r]=rcFromN(n);
    if (p.color==='w' && r===0) p.king=true;
    if (p.color==='b' && r===9) p.king=true;
  }
  function setPiecesFromMap(map){
    pieces.clear();
    for (const [k,v] of map.entries()) pieces.set(k,{color:v.color, king:!!v.king});
  }
  function renderBoard(){
    const board=document.getElementById('board');
    board.innerHTML='';
    for (let r=0;r<10;r++){
      for (let c=0;c<10;c++){
        const dark=(r+c)%2===1;
        const sq=document.createElement('div');
        sq.className='sq '+(dark?'dark':'light');
        if (dark){
          const n=nFromRC(r,c);
          const num=document.createElement('div');
          num.className='num';
          num.textContent=n;
          sq.appendChild(num);

          const p=pieces.get(n);
          if (p){
            const d=document.createElement('div');
            d.className='piece '+p.color+(p.king?' king':'');
            sq.appendChild(d);
          }
        }
        board.appendChild(sq);
      }
    }
  }

  // ============================================================
  //  PDN split/tags
  // ============================================================
  function splitGames(pdnText){
    const txt=(pdnText||'').replace(/\r\n/g,'\n');
    const idx=[], re=/^\s*\[Event\s+/gmi;
    let m;
    while ((m=re.exec(txt))!==null) idx.push(m.index);
    if (!idx.length) return [txt.trim()].filter(Boolean);
    const games=[];
    for (let i=0;i<idx.length;i++){
      const start=idx[i], end=(i+1<idx.length)?idx[i+1]:txt.length;
      const g=txt.slice(start,end).trim();
      if (g) games.push(g);
    }
    return games.length?games:[txt.trim()].filter(Boolean);
  }
  function getTag(gameText,name){
    const re=new RegExp('^\\s*\\['+name+'\\s+"([^"]*)"\\]\\s*$','mi');
    const m=(gameText||'').match(re);
    return m?m[1]:'';
  }
  function extractMovesSectionKeepingVars(gameText){
    let body=(gameText||'').replace(/^\s*\[[^\]]+\]\s*$/gmi,'');
    body=body.replace(/;[^\n]*$/gm,' ');
    body=body.replace(/\b(1-0|0-1|1\/2-1\/2|1-1|\*)\b/g,' ');
    return body;
  }

  // ============================================================
  //  FEN (10x10)
  // ============================================================
  function parseFEN10x10(fen){
    const out={ok:false, side:'w', pieces:new Map()};
    if (!fen || typeof fen!=='string') return out;
    fen=fen.trim();
    const m=fen.match(/^([WB])\s*:\s*(.+)$/i);
    if (!m) return out;
    out.side=(m[1].toUpperCase()==='W')?'w':'b';
    const segs=m[2].split(':').map(s=>s.trim()).filter(Boolean);

    function addPiece(color, king, n){
      if (n<1||n>50) return;
      out.pieces.set(n,{color, king:!!king});
    }
    function parseList(color, listStr){
      let s=(listStr||'').replace(/\s+/g,'');
      if (!s) return;
      const items=s.split(',').filter(Boolean);
      for (let it of items){
        let king=false;
        if (it.startsWith('K')){ king=true; it=it.slice(1); }
        const rm=it.match(/^(\d+)-(\d+)$/);
        if (rm){
          let a=parseInt(rm[1],10), b=parseInt(rm[2],10);
          const step=(a<=b)?1:-1;
          for (let n=a; step>0?n<=b:n>=b; n+=step) addPiece(color,king,n);
          continue;
        }
        const n=parseInt(it,10);
        if (Number.isFinite(n)) addPiece(color,king,n);
      }
    }

    for (const seg of segs){
      const sm=seg.match(/^([WB])(.+)$/i);
      if (!sm) continue;
      const col=(sm[1].toUpperCase()==='W')?'w':'b';
      parseList(col, sm[2]);
    }

    out.ok=true;
    return out;
  }
  function getStartStateForGame(gameText){
    const fen=getTag(gameText,'FEN');
    const setup=getTag(gameText,'SetUp');
    if (fen && setup==='1'){
      const parsed=parseFEN10x10(fen);
      if (parsed.ok) return { startSide:parsed.side, startPieces:parsed.pieces };
    }
    const m=new Map();
    for (let n=31;n<=50;n++) m.set(n,{color:'w',king:false});
    for (let n=1;n<=20;n++)  m.set(n,{color:'b',king:false});
    return { startSide:'w', startPieces:m };
  }

  // ============================================================
  //  Apply move (incl. capture path reconstruction)
  // ============================================================
  function clonePiecesMap(src){
    const m=new Map();
    for (const [k,v] of src.entries()) m.set(k,{color:v.color, king:!!v.king});
    return m;
  }
  function opponent(color){ return color==='w'?'b':'w'; }

  function findUniqueCapturePath(from,to,side,isKing){
    const startMap=clonePiecesMap(pieces);
    const opp=opponent(side);
    const results=[];

    function manCaps(pos,map){
      const [r,c]=rcFromN(pos);
      const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
      const out=[];
      for (const [dr,dc] of dirs){
        const r1=r+dr,c1=c+dc,r2=r+2*dr,c2=c+2*dc;
        if (!inside(r2,c2)) continue;
        const mid=nFromRC(r1,c1), land=nFromRC(r2,c2);
        if (!mid||!land) continue;
        const mp=map.get(mid);
        if (!mp||mp.color!==opp) continue;
        if (map.has(land)) continue;
        out.push({land,cap:mid});
      }
      return out;
    }

    function kingCaps(pos,map){
      const [r,c]=rcFromN(pos);
      const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
      const out=[];
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc, first=null;
        while (inside(rr,cc)){
          const nn=nFromRC(rr,cc);
          if (!nn){ rr+=dr; cc+=dc; continue; }
          if (map.has(nn)){ first=nn; break; }
          rr+=dr; cc+=dc;
        }
        if (!first) continue;
        const fp=map.get(first);
        if (!fp||fp.color!==opp) continue;

        rr+=dr; cc+=dc;
        while (inside(rr,cc)){
          const nn=nFromRC(rr,cc);
          if (!nn){ rr+=dr; cc+=dc; continue; }
          if (map.has(nn)) break;
          out.push({land:nn, cap:first});
          rr+=dr; cc+=dc;
        }
      }
      return out;
    }

    function dfs(cur,map,path){
      if (results.length>1) return;
      if (cur===to && path.length>1){ results.push(path.slice()); return; }
      const nexts=isKing?kingCaps(cur,map):manCaps(cur,map);
      if (!nexts.length) return;
      for (const mv of nexts){
        const map2=clonePiecesMap(map);
        const pc=map2.get(cur);
        if (!pc) continue;
        map2.delete(cur);
        map2.delete(mv.cap);
        map2.set(mv.land, pc);
        const p2=path.slice(); p2.push(mv.land);
        dfs(mv.land,map2,p2);
        if (results.length>1) return;
      }
    }

    const p0=startMap.get(from);
    if (!p0||p0.color!==side) return null;
    dfs(from,startMap,[from]);
    return results.length===1?results[0]:null;
  }

  function removeCapturedBetween(a,b,color){
    const [r1,c1]=rcFromN(a), [r2,c2]=rcFromN(b);
    const dr=Math.sign(r2-r1), dc=Math.sign(c2-c1);
    if (!dr||!dc) return;
    let r=r1+dr, c=c1+dc;
    while (r!==r2 && c!==c2){
      const n=nFromRC(r,c);
      if (n && pieces.has(n)){
        const p=pieces.get(n);
        if (p.color!==color){ pieces.delete(n); return; }
      }
      r+=dr; c+=dc;
    }
  }

  function applyMove(moveObj){
    let {capture,path,side}=moveObj;
    const from=path[0];
    const piece=pieces.get(from);
    if (!piece || piece.color!==side) return false;

    if (capture && path.length===2){
      const to=path[1];
      const full=findUniqueCapturePath(from,to,side,!!piece.king);
      if (full) path=full;
    }

    pieces.delete(from);
    if (capture){
      for (let i=0;i<path.length-1;i++){
        removeCapturedBetween(path[i],path[i+1],side);
      }
    }
    const to=path[path.length-1];
    pieces.set(to,piece);
    promoteIfNeeded(to);
    return true;
  }

  // ============================================================
  //  Variantes + annotations : arbre
  //  FIX PRINCIPAL :
  //  - Une parenthèse après un coup est une ALTERNATIVE à ce coup,
  //    donc la variante se branche sur la position AVANT le coup.
  //  - La variante démarre avec le MÊME camp au trait que le coup remplacé.
  // ============================================================
  let nodeStore=new Map();
  const ROOT='ROOT';

  function resetTree(){
    nodeStore=new Map();
    nodeStore.set(ROOT,{id:ROOT, move:null, comment:'', children:[], parentId:null});
  }

  function stripMoveNumbers(s){ return s.replace(/\b\d+\s*\.(\.\.)?/g,' '); }

  function lex(body){
    const s=stripMoveNumbers(body);
    const out=[];
    let i=0;
    while (i<s.length){
      const ch=s[i];
      if (/\s/.test(ch)){ i++; continue; }
      if (ch==='('){ out.push({t:'('}); i++; continue; }
      if (ch===')'){ out.push({t:')'}); i++; continue; }
      if (ch==='{'){
        let j=i+1;
        while (j<s.length && s[j]!=='}') j++;
        const txt=s.slice(i+1, j<s.length?j:s.length).trim();
        out.push({t:'C', v:txt});
        i=(j<s.length)?j+1:s.length;
        continue;
      }
      let j=i;
      while (j<s.length && !/\s/.test(s[j]) && !'(){}'.includes(s[j])) j++;
      const tok=s.slice(i,j).trim();
      if (tok) out.push({t:'W', v:tok});
      i=j;
    }
    return out;
  }

  function isMoveWord(w){
    return /^[0-9]{1,2}([\-xX][0-9]{1,2})+([!?]{0,2})?$/.test(w);
  }

  function parseMoveToken(tok){
    let annot='';
    const m=tok.match(/([!?]{1,2})$/);
    if (m){ annot=m[1]; tok=tok.slice(0,-annot.length); }
    const isCap=tok.includes('x')||tok.includes('X');
    const sep=isCap?/x|X/:/-/;
    const parts=tok.split(sep).map(s=>parseInt(s,10)).filter(n=>Number.isFinite(n));
    if (parts.length<2) return null;
    return { capture:isCap, path:parts, raw:tok+annot, annot };
  }

  function newNode(parentId, moveObj){
    const id='N'+Math.random().toString(36).slice(2,10);
    nodeStore.set(id,{id, move:moveObj, comment:'', children:[], parentId});
    return id;
  }

  function parseSequence(tokens, idxRef, sideStart, parentId){
    let side=sideStart;
    const seq=[];
    let lastNodeId=null;
    let lastMoveSide=null; // camp qui a joué le dernier coup lu dans cette séquence

    while (idxRef.i<tokens.length){
      const tk=tokens[idxRef.i];

      if (tk.t===')') break;

      if (tk.t==='('){
        idxRef.i++; // skip '('

        // VARIANTE = alternative au coup précédemment lu :
        // branchement sur la position AVANT ce coup => parent du lastNodeId
        let branchPointId = parentId;
        let sideVarStart  = sideStart;

        if (lastNodeId){
          const last = nodeStore.get(lastNodeId);
          branchPointId = (last && last.parentId) ? last.parentId : parentId;

          // La variante démarre avec le même camp au trait que le coup remplacé
          sideVarStart = lastMoveSide ?? sideStart;
        } else {
          // variante sans coup précédent dans la séquence courante :
          // on la branche sur le parent courant et elle démarre au sideStart
          branchPointId = parentId;
          sideVarStart  = sideStart;
        }

        const varSeq = parseSequence(tokens, idxRef, sideVarStart, branchPointId);

        if (tokens[idxRef.i] && tokens[idxRef.i].t===')') idxRef.i++; // consume ')'

        const bp=nodeStore.get(branchPointId);
        bp.children.push(varSeq);
        continue;
      }

      if (tk.t==='C'){
        const targetId=lastNodeId||parentId;
        const n=nodeStore.get(targetId);
        n.comment=(n.comment?n.comment+'\n':'')+tk.v;
        idxRef.i++;
        continue;
      }

      if (tk.t==='W'){
        const w=tk.v;
        if (!isMoveWord(w)){ idxRef.i++; continue; }
        const mv=parseMoveToken(w);
        if (!mv){ idxRef.i++; continue; }

        mv.side=side;

        const nid=newNode(parentId,mv);
        seq.push(nid);
        lastNodeId=nid;
        lastMoveSide=side;

        // Le coup vient d’être joué : la suite continue depuis ce node
        parentId=nid;
        side=(side==='w')?'b':'w';
        idxRef.i++;
        continue;
      }

      idxRef.i++;
    }

    return seq;
  }

  function buildTreeFromGame(gameText, startSide){
    resetTree();
    const body=extractMovesSectionKeepingVars(gameText);
    const tokens=lex(body);
    const idxRef={i:0};
    const mainSeq=parseSequence(tokens, idxRef, startSide, ROOT);
    nodeStore.get(ROOT).children=[mainSeq, ...nodeStore.get(ROOT).children];
    return mainSeq;
  }

  // ============================================================
  //  Branch selection state
  // ============================================================
  const decisions=new Map();  // branchPointNodeId -> chosenVariationIndex(1..)
  const historyStack=[];      // {branchPointId, prevChoice, plyAtChoice}
  function clearDecisions(){ decisions.clear(); historyStack.length=0; }

  function buildActiveLine(){
    const line=[];
    function walkSeq(seq){
      for (const nid of seq){
        line.push(nid);

        const n=nodeStore.get(nid);
        const choice=decisions.has(nid)?decisions.get(nid):0;

        if (n.children && n.children.length && choice>0 && n.children[choice-1]){
          walkSeq(n.children[choice-1]);
          return; // stop main continuation after branching
        }
      }
    }
    const root=nodeStore.get(ROOT);
    const main=(root.children && root.children[0])?root.children[0]:[];
    walkSeq(main);
    return line;
  }

  // ============================================================
  //  UI
  // ============================================================
  const firstBtn=document.getElementById('first');
  const prevBtn=document.getElementById('prev');
  const playBtn=document.getElementById('play');
  const nextBtn=document.getElementById('next');
  const lastBtn=document.getElementById('last');
  const backBranchBtn=document.getElementById('backBranch');
  const backMainBtn=document.getElementById('backMain');

  const info=document.getElementById('info');
  const msg=document.getElementById('msg');
  const gameSel=document.getElementById('gameSel');
  const commentMeta=document.getElementById('commentMeta');
  const commentBox=document.getElementById('commentBox');
  const varList=document.getElementById('varList');
  const crumb=document.getElementById('crumb');

  let timer=null;
  let allGames=[];
  let currentGameIndex=1;

  let startSide='w';
  let startPiecesMap=null;

  let activeLine=[];
  let plyIndex=0;

  function stop(){
    if (timer){ clearInterval(timer); timer=null; }
    playBtn.textContent='▶︎';
  }
  function showError(t){ msg.textContent=t||''; }

  function niceSide(s){ return s==='w'?'Blancs':'Noirs'; }
  function annotLabel(a){
    if (!a) return '';
    if (a==='??') return 'Gaffe';
    if (a==='?!') return 'Imprécision';
    if (a==='!?') return 'Intéressant';
    if (a==='!')  return 'Bon';
    if (a==='?')  return 'Douteux';
    return a;
  }

  function buildMeta(){
    const gameText=allGames[currentGameIndex-1]||'';
    const event=getTag(gameText,'Event');
    const date=getTag(gameText,'Date');
    const white=getTag(gameText,'White');
    const black=getTag(gameText,'Black');
    const fen=getTag(gameText,'FEN');
    return [`Partie ${currentGameIndex}`, event, date, (white&&black)?(white+' / '+black):'', fen?'FEN':'']
      .filter(Boolean).join(' — ');
  }

  function updateControls(){
    firstBtn.disabled=(plyIndex===0);
    prevBtn.disabled=(plyIndex===0);
    nextBtn.disabled=(plyIndex===activeLine.length);
    lastBtn.disabled=(plyIndex===activeLine.length);

    backBranchBtn.disabled=(historyStack.length===0);
    backMainBtn.disabled=(historyStack.length===0);

    info.textContent=`Demi-temps ${plyIndex}/${activeLine.length} — ${buildMeta()}`;
  }

  function applyLineUpTo(ply){
    setPiecesFromMap(startPiecesMap);
    for (let i=0;i<ply;i++){
      const nid=activeLine[i];
      const node=nodeStore.get(nid);
      if (!node || !node.move) break;
      applyMove(node.move);
    }
  }

  function rebuildTo(ply){
    plyIndex=Math.max(0, Math.min(ply, activeLine.length));
    applyLineUpTo(plyIndex);
    renderBoard();
    renderCommentAndVariants();
    updateControls();
  }

  function stepNext(){
    if (plyIndex>=activeLine.length){ stop(); return; }
    const nid=activeLine[plyIndex];
    const node=nodeStore.get(nid);
    if (node && node.move) applyMove(node.move);
    plyIndex++;
    renderBoard();
    renderCommentAndVariants();
    updateControls();
  }

  function stepPrev(){
    if (plyIndex<=0) return;
    rebuildTo(plyIndex-1);
  }

  function goFirst(){ stop(); rebuildTo(0); }
  function goLast(){ stop(); rebuildTo(activeLine.length); }

  firstBtn.addEventListener('click', goFirst);
  lastBtn.addEventListener('click', goLast);
  prevBtn.addEventListener('click', ()=>{ stop(); stepPrev(); });
  nextBtn.addEventListener('click', ()=>{ stop(); stepNext(); });

  playBtn.addEventListener('click', ()=>{
    if (timer){ stop(); return; }
    timer=setInterval(()=>{ if (plyIndex>=activeLine.length){ stop(); return; } stepNext(); }, 650);
    playBtn.textContent='⏸';
  });

  backBranchBtn.addEventListener('click', ()=>{
    if (!historyStack.length) return;
    stop();
    const h=historyStack.pop();
    if (h.prevChoice===null) decisions.delete(h.branchPointId);
    else decisions.set(h.branchPointId, h.prevChoice);
    activeLine=buildActiveLine();
    rebuildTo(Math.min(h.plyAtChoice, activeLine.length));
  });

  backMainBtn.addEventListener('click', ()=>{
    if (!historyStack.length) return;
    stop();
    clearDecisions();
    activeLine=buildActiveLine();
    rebuildTo(Math.min(plyIndex, activeLine.length));
  });

  function renderCommentAndVariants(){
    // commentaire = coup joué (plyIndex-1)
    if (plyIndex===0){
      commentMeta.textContent=`Départ — ${niceSide(startSide)} au trait`;
      commentBox.textContent='—';
    } else {
      const nid=activeLine[plyIndex-1];
      const node=nodeStore.get(nid);
      const mv=node?.move;
      const cm=(node?.comment||'').trim();
      const ann=mv?.annot||'';
      const annTxt=ann?` — ${annotLabel(ann)}`:'';
      commentMeta.textContent=`${niceSide(mv.side)} joue : ${mv.raw}${annTxt}`;
      commentBox.textContent=cm?cm:'—';
    }

    // Variantes à la position COURANTE :
    // point = dernier coup joué (plyIndex-1), ou ROOT au départ.
    varList.innerHTML='';
    let bpId=null;
    let bpLabel='';
    if (plyIndex===0){
      bpId=ROOT;
      bpLabel='Départ';
    } else {
      bpId=activeLine[plyIndex-1];
      bpLabel=nodeStore.get(bpId)?.move?.raw||'Position';
    }

    const bp=nodeStore.get(bpId);
    const vars=(bp && bp.children)?bp.children:[];

    const branchInfo=historyStack.length?`Choix: ${historyStack.length}`:'Ligne principale';
    crumb.innerHTML=`<span class="badge">${branchInfo}</span> <span style="margin-left:6px;">Point : ${bpLabel}</span>`;

    // Sur ROOT : children[0] = ligne principale, les suivantes sont des variantes éventuelles du départ
    const varSeqs = (bpId===ROOT) ? vars.slice(1) : vars;

    if (!varSeqs.length){
      const div=document.createElement('div');
      div.style.fontSize='13px';
      div.style.color='var(--muted)';
      div.style.opacity='.9';
      div.textContent='Aucune variante à cet endroit.';
      varList.appendChild(div);
      return;
    }

    varSeqs.forEach((seq, i)=>{
      const first = seq && seq.length ? nodeStore.get(seq[0]) : null;
      const title = first?.move?.raw ? first.move.raw : '(vide)';
      const side = first?.move?.side ? niceSide(first.move.side) : '';
      const cm = (first?.comment||'').trim();
      const ann = first?.move?.annot || '';
      const annTxt = ann ? ` ${ann}` : '';

      const btn=document.createElement('button');
      btn.className='varBtn';
      btn.type='button';
      btn.innerHTML=`▶ Variante ${i+1} : ${title}${annTxt}<small>${side}${cm?' • '+cm.split('\n')[0].slice(0,120):''}</small>`;

      btn.addEventListener('click', ()=>{
        stop();
        const prevChoice = decisions.has(bpId) ? decisions.get(bpId) : null;
        decisions.set(bpId, i+1);
        historyStack.push({branchPointId:bpId, prevChoice, plyAtChoice:plyIndex});
        activeLine=buildActiveLine();
        // On reste au même demi-temps (position inchangée), la suite changera dès le prochain coup
        rebuildTo(Math.min(plyIndex, activeLine.length));
      });

      varList.appendChild(btn);
    });
  }

  function fillSelector(){
    gameSel.innerHTML='';
    for (let i=0;i<allGames.length;i++){
      const g=allGames[i];
      const white=getTag(g,'White');
      const black=getTag(g,'Black');
      const event=getTag(g,'Event');
      const opt=document.createElement('option');
      opt.value=String(i+1);
      const labelPlayers=(white||black)?`${white} / ${black}`:'';
      opt.textContent=[`Partie ${i+1}`,labelPlayers,event].filter(Boolean).join(' — ');
      gameSel.appendChild(opt);
    }
    gameSel.value=String(currentGameIndex);
  }

  function setGame(index, plyToJump){
    stop();
    currentGameIndex=Math.max(1, Math.min(index, allGames.length||1));
    const gameText=allGames[currentGameIndex-1] || allGames[0] || '';

    const st=getStartStateForGame(gameText);
    startSide=st.startSide;
    startPiecesMap=st.startPieces;

    clearDecisions();
    buildTreeFromGame(gameText, startSide);
    activeLine=buildActiveLine();

    fillSelector();
    rebuildTo(plyToJump ?? 0);

    showError(activeLine.length ? '' : 'PDN chargé, mais aucun coup détecté.');
  }

  gameSel.addEventListener('change', ()=>{
    const v=parseInt(gameSel.value,10);
    if (!Number.isFinite(v)) return;
    setGame(v, 0);
  });

  // ============================================================
  //  URL params ?src=... and #ply
  // ============================================================
  function getQueryParam(name){
    try{ return new URL(location.href).searchParams.get(name); }catch(_e){ return null; }
  }
  function getHashPly(){
    const h=(location.hash||'').replace('#','').trim();
    const n=parseInt(h,10);
    return Number.isFinite(n)&&n>=0?n:null;
  }
  function readEmbeddedPDNById(id){
    if (!id) return '';
    const el=document.getElementById(id);
    return el ? (el.textContent||'').trim() : '';
  }

  function loadFromPDNText(pdnText, plyToJump, gameIndex){
    allGames=splitGames(pdnText||'');
    if (!allGames.length) allGames=[''];
    currentGameIndex=1;
    fillSelector();

    const g = Number.isFinite(gameIndex) ? gameIndex : 1;
    setGame(g, plyToJump ?? 0);
    showError('');
  }

  // ============================================================
  //  Responsive width snap
  // ============================================================
  function snapBoardSize(){
    const max=560;
    const desired=Math.min(window.innerWidth*0.92, max);
    const snapped=Math.max(320, Math.floor(desired/10)*10);
    document.documentElement.style.setProperty('--w', snapped+'px');
  }
  window.addEventListener('resize', snapBoardSize);
  setTimeout(snapBoardSize,0);
  setTimeout(snapBoardSize,200);

  // ============================================================
  //  Init
  // ============================================================
  const std=new Map();
  for (let n=31;n<=50;n++) std.set(n,{color:'w',king:false});
  for (let n=1;n<=20;n++)  std.set(n,{color:'b',king:false});
  startSide='w';
  startPiecesMap=std;
  setPiecesFromMap(startPiecesMap);

  resetTree();
  activeLine=[];
  plyIndex=0;
  renderBoard();
  renderCommentAndVariants();
  updateControls();
  showError('En attente du PDN…');

  // READY
  try{ window.parent.postMessage({type:'OPL_READY'}, '*'); }catch(_e){}

  // Embedded in iframe (optional): ?src=opl-pdn#111
  const src=getQueryParam('src') || 'opl-pdn';
  const embedded=readEmbeddedPDNById(src);
  if (embedded){
    const ply=getHashPly() ?? 0;
    loadFromPDNText(embedded, ply, 1);
  }

  // postMessage (NEWS -> IFRAME)
  window.addEventListener('message', (e)=>{
    if (!e || !e.data) return;
    if (e.data.type==='OPL_PDN'){
      const pdn=(typeof e.data.pdn==='string')?e.data.pdn:'';
      if (!pdn.trim()) return;
      const ply=parseInt(e.data.ply,10);
      const plyToJump=Number.isFinite(ply)?ply:0;
      const game=parseInt(e.data.game,10);
      const gameIndex=Number.isFinite(game)?game:1;
      stop();
      loadFromPDNText(pdn, plyToJump, gameIndex);
    }
    if (e.data.type==='OPL_GOTO'){
      const ply=parseInt(e.data.ply,10);
      if (!Number.isFinite(ply)) return;
      stop();
      rebuildTo(ply);
    }
  });

})();
</script>
</body>
</html>
