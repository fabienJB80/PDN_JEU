<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OPL2 – Lecteur PDN (FEN + variantes + annotations)</title>

  <style>
    :root{
      --panel:#f3efe6;
      --border:#d8cfbf;
      --light:#efe4cf;
      --dark:#a8743a;
      --ink:#2b2b2b;
      --muted:#6b3f2c;
      --w: 520px;
    }

    html,body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--ink)}
    body{
      background:#fff;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:12px;
    }

    .wrap{
      width:var(--w);
      max-width:var(--w);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .topbar{display:flex; gap:10px; align-items:center}
    .selectWrap{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:var(--muted);
      width:100%;
      min-width:0;
    }
    .selectWrap strong{white-space:nowrap}
    select{
      width:100%;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-size:13px;
      outline:none;
      min-width:0;
    }

    /* ===== SCORE (zone dédiée) ===== */
    .score{
      text-align:center;
      font-size:13px;
      font-weight:800;
      color:var(--muted);
      user-select:none;
      margin-top:-2px;
    }
    .score:empty{display:none;}

    .board{
      width:100%;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(10,1fr);
      grid-template-rows:repeat(10,1fr);
      outline:1px solid rgba(0,0,0,.12);
      border-radius:12px;
      overflow:hidden;
      box-shadow:0 8px 30px rgba(0,0,0,.20);
      background:#000;
    }

    .sq{position:relative; display:flex; align-items:center; justify-content:center}
    .light{background:var(--light)}
    .dark{background:var(--dark)}

    /* ===== NUMEROS TOUJOURS VISIBLES (même sous pions blancs) ===== */
    .num{
      position:absolute;
      top:3px; left:5px;
      font-size:12px;
      font-weight:800;
      opacity:.95;
      color:#000;
      user-select:none;
      pointer-events:none;
      line-height:1;
      z-index:5; /* AU-DESSUS des pions */
      text-shadow:
        -1px 0 rgba(255,255,255,.90),
         1px 0 rgba(255,255,255,.90),
         0 -1px rgba(255,255,255,.90),
         0  1px rgba(255,255,255,.90),
         0  0 2px rgba(0,0,0,.25);
    }
    .dark .num{
      color:#fff;
      opacity:.95;
      text-shadow:
        -1px 0 rgba(0,0,0,.80),
         1px 0 rgba(0,0,0,.80),
         0 -1px rgba(0,0,0,.80),
         0  1px rgba(0,0,0,.80),
         0  0 2px rgba(0,0,0,.20);
    }

    .piece{
      width:72%;
      aspect-ratio:1/1;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: inset 0 3px 0 rgba(255,255,255,.18), 0 6px 12px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.35);
      position:relative;
      z-index:2; /* SOUS les numéros */
    }
    .w{background:#f6f1e8}
    .b{background:#1a1a1a}
    .king::after{
      content:"K";
      font-weight:800;
      font-size:18px;
      color:rgba(255,255,255,.85);
      text-shadow:0 1px 0 rgba(0,0,0,.6);
    }
    .w.king::after{color:rgba(0,0,0,.75); text-shadow:none}

    .bar{
      display:flex; gap:6px; align-items:center; justify-content:center;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      flex-wrap:wrap;
    }
    button{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid #cdbfa9;
      background:#fff;
      cursor:pointer;
      font-weight:800;
      min-width:44px;
      font-size:14px;
      line-height:1;
    }
    button:disabled{opacity:.55; cursor:not-allowed}

    .info{
      flex:1;
      text-align:center;
      font-size:12px;
      color:var(--muted);
      user-select:none;
      padding:0 8px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    .panels{display:grid; grid-template-columns:1fr; gap:10px}
    .panel{
      background:#fff;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      box-shadow:0 4px 14px rgba(0,0,0,.08);
    }
    .panel h3{margin:0 0 8px 0; font-size:13px; color:var(--muted)}
    .commentMeta{font-size:12px; color:var(--muted); opacity:.9; margin:0 0 6px 0}
    .commentBox{font-size:13px; line-height:1.35; white-space:pre-wrap; word-break:break-word}

    .varsHeader{display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .crumb{
      font-size:12px; color:var(--muted); opacity:.95;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100%;
    }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:var(--panel);
      border:1px solid var(--border);
      font-size:11px;
      color:var(--muted);
      font-weight:800;
    }
    .varList{display:flex; flex-direction:column; gap:6px}
    .varBtn{
      width:100%;
      text-align:left;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fafafa;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      line-height:1.2;
      color:#2b2b2b;
    }
    .varBtn small{
      display:block;
      font-weight:600;
      color:var(--muted);
      opacity:.9;
      margin-top:2px;
    }
    .varBtn:hover{background:#fff}

    .msg{
      color:#b00020;
      font-family:ui-monospace,Consolas,monospace;
      font-size:12px;
      text-align:center;
      opacity:.95;
      min-height:16px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="selectWrap">
        <strong>Partie</strong>
        <select id="gameSel" aria-label="Sélection de la partie">
          <option value="1">En attente…</option>
        </select>
      </div>
    </div>

    <div id="score" class="score"></div>

    <div id="board" class="board" aria-label="Damier"></div>

    <div class="bar">
      <button id="first" title="Début">⏮</button>
      <button id="prev"  title="Demi-temps précédent">⟵</button>
      <button id="play"  title="Lecture / Pause">▶︎</button>
      <button id="next"  title="Demi-temps suivant">⟶</button>
      <button id="last"  title="Fin">⏭</button>

      <button id="backBranch" title="Retour au point de branchement">↩</button>
      <button id="backMain"   title="Retour à la ligne principale">⇦</button>

      <div id="info" class="info">En attente…</div>
    </div>

    <div class="panels">
      <div class="panel">
        <h3>Commentaire</h3>
        <div id="commentMeta" class="commentMeta"></div>
        <div id="commentBox" class="commentBox">—</div>
      </div>

      <div class="panel">
        <div class="varsHeader">
          <h3 style="margin:0;">Variantes</h3>
          <div id="crumb" class="crumb"></div>
        </div>
        <div id="varList" class="varList" style="margin-top:8px;"></div>
      </div>
    </div>

    <div id="msg" class="msg"></div>
  </div>

<script>
(() => {

  // ============================================================
  //  UI (INDISPENSABLE : sinon SR reste "En attente…")
  // ============================================================
  const firstBtn=document.getElementById('first');
  const prevBtn=document.getElementById('prev');
  const playBtn=document.getElementById('play');
  const nextBtn=document.getElementById('next');
  const lastBtn=document.getElementById('last');
  const backBranchBtn=document.getElementById('backBranch');
  const backMainBtn=document.getElementById('backMain');

  const info=document.getElementById('info');
  const msg=document.getElementById('msg');
  const gameSel=document.getElementById('gameSel');
  const commentMeta=document.getElementById('commentMeta');
  const commentBox=document.getElementById('commentBox');
  const varList=document.getElementById('varList');
  const crumb=document.getElementById('crumb');
  const scoreEl=document.getElementById('score');

  let timer=null;
  let allGames=[];
  let currentGameIndex=1;

  let startSide='w';
  let startPiecesMap=null;

  let activeLine=[];
  let plyIndex=0;

  function stop(){
    if (timer){ clearInterval(timer); timer=null; }
    playBtn.textContent='▶︎';
  }

  // ============================================================
  //  Helpers cases
  // ============================================================
  function rcFromN(n){
    const i=n-1, r=Math.floor(i/5), k=i%5;
    const c=(r%2===0)?(1+2*k):(0+2*k);
    return [r,c];
  }
  function nFromRC(r,c){
    if ((r+c)%2===0) return null;
    const k=(r%2===0)?(c-1)/2:c/2;
    if (!Number.isInteger(k) || k<0 || k>4) return null;
    return r*5+k+1;
  }
  function inside(r,c){ return r>=0&&r<10&&c>=0&&c<10; }

  // ============================================================
  //  Board model
  // ============================================================
  const pieces=new Map();
  function promoteIfNeeded(n){
    const p=pieces.get(n);
    if (!p || p.king) return;
    const [r]=rcFromN(n);
    if (p.color==='w' && r===0) p.king=true;
    if (p.color==='b' && r===9) p.king=true;
  }
  function setPiecesFromMap(map){
    pieces.clear();
    for (const [k,v] of map.entries()) pieces.set(k,{color:v.color, king:!!v.king});
  }
  function renderBoard(){
    const board=document.getElementById('board');
    board.innerHTML='';
    for (let r=0;r<10;r++){
      for (let c=0;c<10;c++){
        const dark=(r+c)%2===1;
        const sq=document.createElement('div');
        sq.className='sq '+(dark?'dark':'light');
        if (dark){
          const n=nFromRC(r,c);
          const num=document.createElement('div');
          num.className='num';
          num.textContent=n;
          sq.appendChild(num);

          const p=pieces.get(n);
          if (p){
            const d=document.createElement('div');
            d.className='piece '+p.color+(p.king?' king':'');
            sq.appendChild(d);
          }
        }
        board.appendChild(sq);
      }
    }
  }

  // ============================================================
  //  PDN split/tags
  // ============================================================
  function splitGames(pdnText){
    const txt=(pdnText||'').replace(/\r\n/g,'\n');
    const idx=[], re=/^\s*\[Event\s+/gmi;
    let m;
    while ((m=re.exec(txt))!==null) idx.push(m.index);
    if (!idx.length) return [txt.trim()].filter(Boolean);
    const games=[];
    for (let i=0;i<idx.length;i++){
      const start=idx[i], end=(i+1<idx.length)?idx[i+1]:txt.length;
      const g=txt.slice(start,end).trim();
      if (g) games.push(g);
    }
    return games.length?games:[txt.trim()].filter(Boolean);
  }
  function getTag(gameText,name){
    const re=new RegExp('^\\s*\\['+name+'\\s+"([^"]*)"\\]\\s*$','mi');
    const m=(gameText||'').match(re);
    return m?m[1]:'';
  }
  function extractMovesSectionKeepingVars(gameText){
    let body=(gameText||'').replace(/^\s*\[[^\]]+\]\s*$/gmi,'');
    body=body.replace(/;[^\n]*$/gm,' ');
    body=body.replace(/\b(1-0|0-1|1\/2-1\/2|1-1|\*)\b/g,' ');
    return body;
  }

  // ============================================================
  //  FEN (10x10)
  // ============================================================
  function parseFEN10x10(fen){
    const out={ok:false, side:'w', pieces:new Map()};
    if (!fen || typeof fen!=='string') return out;
    fen=fen.trim();
    const m=fen.match(/^([WB])\s*:\s*(.+)$/i);
    if (!m) return out;
    out.side=(m[1].toUpperCase()==='W')?'w':'b';
    const segs=m[2].split(':').map(s=>s.trim()).filter(Boolean);

    function addPiece(color, king, n){
      if (n<1||n>50) return;
      out.pieces.set(n,{color, king:!!king});
    }
    function parseList(color, listStr){
      let s=(listStr||'').replace(/\s+/g,'');
      if (!s) return;
      const items=s.split(',').filter(Boolean);
      for (let it of items){
        let king=false;
        if (it.startsWith('K')){ king=true; it=it.slice(1); }
        const rm=it.match(/^(\d+)-(\d+)$/);
        if (rm){
          let a=parseInt(rm[1],10), b=parseInt(rm[2],10);
          const step=(a<=b)?1:-1;
          for (let n=a; step>0?n<=b:n>=b; n+=step) addPiece(color,king,n);
          continue;
        }
        const n=parseInt(it,10);
        if (Number.isFinite(n)) addPiece(color,king,n);
      }
    }

    for (const seg of segs){
      const sm=seg.match(/^([WB])(.+)$/i);
      if (!sm) continue;
      const col=(sm[1].toUpperCase()==='W')?'w':'b';
      parseList(col, sm[2]);
    }

    out.ok=true;
    return out;
  }
  function getStartStateForGame(gameText){
    const fen=getTag(gameText,'FEN');
    const setup=getTag(gameText,'SetUp');
    if (fen && setup==='1'){
      const parsed=parseFEN10x10(fen);
      if (parsed.ok) return { startSide:parsed.side, startPieces:parsed.pieces };
    }
    const m=new Map();
    for (let n=31;n<=50;n++) m.set(n,{color:'w',king:false});
    for (let n=1;n<=20;n++)  m.set(n,{color:'b',king:false});
    return { startSide:'w', startPieces:m };
  }

  // ============================================================
  //  Apply move (incl. capture path reconstruction)
  // ============================================================
  function clonePiecesMap(src){
    const m=new Map();
    for (const [k,v] of src.entries()) m.set(k,{color:v.color, king:!!v.king});
    return m;
  }
  function opponent(color){ return color==='w'?'b':'w'; }

  function findUniqueCapturePath(from,to,side,isKing){
    const startMap=clonePiecesMap(pieces);
    const opp=opponent(side);
    const results=[];

    function manCaps(pos,map){
      const [r,c]=rcFromN(pos);
      const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
      const out=[];
      for (const [dr,dc] of dirs){
        const r1=r+dr,c1=c+dc,r2=r+2*dr,c2=c+2*dc;
        if (!inside(r2,c2)) continue;
        const mid=nFromRC(r1,c1), land=nFromRC(r2,c2);
        if (!mid||!land) continue;
        const mp=map.get(mid);
        if (!mp||mp.color!==opp) continue;
        if (map.has(land)) continue;
        out.push({land,cap:mid});
      }
      return out;
    }

    function kingCaps(pos,map){
      const [r,c]=rcFromN(pos);
      const dirs=[[-1,-1],[-1,1],[1,-1],[1,1]];
      const out=[];
      for (const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc, first=null;
        while (inside(rr,cc)){
          const nn=nFromRC(rr,cc);
          if (!nn){ rr+=dr; cc+=dc; continue; }
          if (map.has(nn)){ first=nn; break; }
          rr+=dr; cc+=dc;
        }
        if (!first) continue;
        const fp=map.get(first);
        if (!fp||fp.color!==opp) continue;

        rr+=dr; cc+=dc;
        while (inside(rr,cc)){
          const nn=nFromRC(rr,cc);
          if (!nn){ rr+=dr; cc+=dc; continue; }
          if (map.has(nn)) break;
          out.push({land:nn, cap:first});
          rr+=dr; cc+=dc;
        }
      }
      return out;
    }

    function dfs(cur,map,path){
      if (results.length>1) return;
      if (cur===to && path.length>1){ results.push(path.slice()); return; }
      const nexts=isKing?kingCaps(cur,map):manCaps(cur,map);
      if (!nexts.length) return;
      for (const mv of nexts){
        const map2=clonePiecesMap(map);
        const pc=map2.get(cur);
        if (!pc) continue;
        map2.delete(cur);
        map2.delete(mv.cap);
        map2.set(mv.land, pc);
        const p2=path.slice(); p2.push(mv.land);
        dfs(mv.land,map2,p2);
        if (results.length>1) return;
      }
    }

    const p0=startMap.get(from);
    if (!p0||p0.color!==side) return null;
    dfs(from,startMap,[from]);
    return results.length===1?results[0]:null;
  }

  function removeCapturedBetween(a,b,color){
    const [r1,c1]=rcFromN(a), [r2,c2]=rcFromN(b);
    const dr=Math.sign(r2-r1), dc=Math.sign(c2-c1);
    if (!dr||!dc) return;
    let r=r1+dr, c=c1+dc;
    while (r!==r2 && c!==c2){
      const n=nFromRC(r,c);
      if (n && pieces.has(n)){
        const p=pieces.get(n);
        if (p.color!==color){ pieces.delete(n); return; }
      }
      r+=dr; c+=dc;
    }
  }

  function applyMove(moveObj){
    let {capture,path,side}=moveObj;
    const from=path[0];
    const piece=pieces.get(from);
    if (!piece || piece.color!==side) return false;

    if (capture && path.length===2){
      const to=path[1];
      const full=findUniqueCapturePath(from,to,side,!!piece.king);
      if (full) path=full;
    }

    pieces.delete(from);
    if (capture){
      for (let i=0;i<path.length-1;i++){
        removeCapturedBetween(path[i],path[i+1],side);
      }
    }
    const to=path[path.length-1];
    pieces.set(to,piece);
    promoteIfNeeded(to);
    return true;
  }

  // ============================================================
  //  Variantes + annotations : arbre
  // ============================================================
  let nodeStore=new Map();
  const ROOT='ROOT';

  function resetTree(){
    nodeStore=new Map();
    nodeStore.set(ROOT,{id:ROOT, move:null, comment:'', children:[], parentId:null, nextIds:[]});
  }

  function stripMoveNumbers(s){ return s.replace(/\b\d+\s*\.(\.\.)?/g,' '); }

  function lex(body){
    const s=stripMoveNumbers(body);
    const out=[];
    let i=0;
    while (i<s.length){
      const ch=s[i];
      if (/\s/.test(ch)){ i++; continue; }
      if (ch==='('){ out.push({t:'('}); i++; continue; }
      if (ch===')'){ out.push({t:')'}); i++; continue; }
      if (ch==='{'){
        let j=i+1;
        while (j<s.length && s[j]!=='}') j++;
        const txt=s.slice(i+1, j<s.length?j:s.length).trim();
        out.push({t:'C', v:txt});
        i=(j<s.length)?j+1:s.length;
        continue;
      }
      let j=i;
      while (j<s.length && !/\s/.test(s[j]) && !'(){}'.includes(s[j])) j++;
      const tok=s.slice(i,j).trim();
      if (tok) out.push({t:'W', v:tok});
      i=j;
    }
    return out;
  }

  function isMoveWord(w){
    return /^[0-9]{1,2}([\-xX][0-9]{1,2})+([!?]{0,2})?$/.test(w);
  }

  function parseMoveToken(tok){
    let annot='';
    const m=tok.match(/([!?]{1,2})$/);
    if (m){ annot=m[1]; tok=tok.slice(0,-annot.length); }
    const isCap=tok.includes('x')||tok.includes('X');
    const sep=isCap?/x|X/:/-/;
    const parts=tok.split(sep).map(s=>parseInt(s,10)).filter(n=>Number.isFinite(n));
    if (parts.length<2) return null;
    return { capture:isCap, path:parts, raw:tok+annot, annot };
  }

  function newNode(parentId, moveObj){
    const id='N'+Math.random().toString(36).slice(2,10);
    nodeStore.set(id,{id, move:moveObj, comment:'', children:[], parentId, nextIds:[]});
    return id;
  }

  function parseSequence(tokens, idxRef, sideStart, parentId){
    let side=sideStart;
    const seq=[];
    let lastNodeId=null;
    let lastMoveSide=null;

    while (idxRef.i<tokens.length){
      const tk=tokens[idxRef.i];

      if (tk.t===')') break;

      if (tk.t==='('){
        idxRef.i++;

        let branchPointId = parentId;
        let sideVarStart  = sideStart;

        if (lastNodeId){
          const last = nodeStore.get(lastNodeId);
          branchPointId = (last && last.parentId) ? last.parentId : parentId;
          sideVarStart = lastMoveSide ?? sideStart;
        } else {
          branchPointId = parentId;
          sideVarStart  = sideStart;
        }

        const varSeq = parseSequence(tokens, idxRef, sideVarStart, branchPointId);

        if (tokens[idxRef.i] && tokens[idxRef.i].t===')') idxRef.i++;

        const bp=nodeStore.get(branchPointId);
        bp.children.push(varSeq);
        continue;
      }

      if (tk.t==='C'){
        const targetId=lastNodeId||parentId;
        const n=nodeStore.get(targetId);
        n.comment=(n.comment?n.comment+'\n':'')+tk.v;
        idxRef.i++;
        continue;
      }

      if (tk.t==='W'){
        const w=tk.v;
        if (!isMoveWord(w)){ idxRef.i++; continue; }
        const mv=parseMoveToken(w);
        if (!mv){ idxRef.i++; continue; }

        mv.side=side;

        const nid=newNode(parentId,mv);
        seq.push(nid);
        lastNodeId=nid;
        lastMoveSide=side;

        parentId=nid;
        side=(side==='w')?'b':'w';
        idxRef.i++;
        continue;
      }

      idxRef.i++;
    }

    return seq;
  }

  // ✅ Lien "nextIds" partout (principale + variantes + sous-variantes)
  function linkAllNext(){
    const seenSeq = new Set();

    function linkSeq(seq){
      if (!seq || !seq.length) return;
      // éviter de relinker la même séquence si référencée plusieurs fois
      const key = seq.join(',');
      if (seenSeq.has(key)) return;
      seenSeq.add(key);

      for (let i=0;i<seq.length;i++){
        const id=seq[i];
        const n=nodeStore.get(id);
        if (!n) continue;
        n.nextIds = (i+1<seq.length) ? [seq[i+1]] : [];
      }
      for (const id of seq){
        const n=nodeStore.get(id);
        if (n && n.children && n.children.length){
          for (const childSeq of n.children) linkSeq(childSeq);
        }
      }
    }

    const root=nodeStore.get(ROOT);
    if (root && root.children && root.children.length){
      for (const seq of root.children) linkSeq(seq);
    }
  }

  function buildTreeFromGame(gameText, startSide){
    resetTree();
    const body=extractMovesSectionKeepingVars(gameText);
    const tokens=lex(body);
    const idxRef={i:0};
    const mainSeq=parseSequence(tokens, idxRef, startSide, ROOT);

    // root.children[0] = principale
    nodeStore.get(ROOT).children=[mainSeq, ...nodeStore.get(ROOT).children];

    // ✅ indispensable pour buildActiveLine() + navigation
    linkAllNext();

    return mainSeq;
  }

  // ============================================================
  //  Branch selection state
  // ============================================================
  const decisions=new Map();
  const historyStack=[];
  function clearDecisions(){ decisions.clear(); historyStack.length=0; }

  function showError(t){ msg.textContent=t||''; }

  function niceSide(s){ return s==='w'?'Blancs':'Noirs'; }
  function annotLabel(a){
    if (!a) return '';
    if (a==='??') return 'Gaffe';
    if (a==='?!') return 'Imprécision';
    if (a==='!?') return 'Intéressant';
    if (a==='!')  return 'Bon';
    if (a==='?')  return 'Douteux';
    return a;
  }

  // ============================================================
  //  buildActiveLine (robuste + conserve les autres nœuds à variantes)
  // ============================================================
  function buildActiveLine(){
    const line = [];
    const visited = new Set();
    const stack = [];

    const root = nodeStore.get(ROOT);
    if (!root || !root.children || !root.children.length) return line;

    // ROOT : 0 = principale (children[0]), 1 = var1 (children[1]) ...
    const rootChoice = decisions.has(ROOT) ? decisions.get(ROOT) : 0;
    const startSeq = root.children[rootChoice] || root.children[0] || [];
    let cur = startSeq.length ? startSeq[0] : null;

    while (cur){
      if (visited.has(cur)) break;
      visited.add(cur);

      line.push(cur);

      const node = nodeStore.get(cur);
      if (!node) break;

      const choice = decisions.has(cur) ? decisions.get(cur) : 0;

      // Variante choisie sur ce nœud (1..n => children[0..n-1])
      if (choice > 0 && node.children && node.children.length){
        const seq = node.children[choice - 1];
        if (seq && seq.length){
          const normalNext = (node.nextIds && node.nextIds.length) ? node.nextIds[0] : null;
          stack.push(normalNext);
          cur = seq[0];
          continue;
        }
      }

      // suite normale
      if (node.nextIds && node.nextIds.length){
        cur = node.nextIds[0];
        continue;
      }

      // fin de branche : revenir à la suite principale empilée
      if (stack.length){
        cur = stack.pop();
        continue;
      }

      break;
    }

    return line;
  }

  /* Score affiché dans sa zone dédiée */
  function updateScoreLine(){
    const gameText=allGames[currentGameIndex-1]||'';
    const r=(getTag(gameText,'Result')||'').trim();
    scoreEl.textContent = (r && r!=='*') ? ('Score : '+r) : '';
  }

  function buildMeta(){
    const gameText=allGames[currentGameIndex-1]||'';
    const event=getTag(gameText,'Event');
    const date=getTag(gameText,'Date');
    const white=getTag(gameText,'White');
    const black=getTag(gameText,'Black');
    const fen=getTag(gameText,'FEN');
    return [`Partie ${currentGameIndex}`, event, date, (white&&black)?(white+' / '+black):'', fen?'FEN':'']
      .filter(Boolean).join(' — ');
  }

  function updateControls(){
    firstBtn.disabled=(plyIndex===0);
    prevBtn.disabled=(plyIndex===0);
    nextBtn.disabled=(plyIndex===activeLine.length);
    lastBtn.disabled=(plyIndex===activeLine.length);

    backBranchBtn.disabled=(historyStack.length===0);
    backMainBtn.disabled=(historyStack.length===0);

    info.textContent=`Demi-temps ${plyIndex}/${activeLine.length} — ${buildMeta()}`;
  }

  function applyLineUpTo(ply){
    setPiecesFromMap(startPiecesMap);
    for (let i=0;i<ply;i++){
      const nid=activeLine[i];
      const node=nodeStore.get(nid);
      if (!node || !node.move) break;
      applyMove(node.move);
    }
  }

  function rebuildTo(ply){
    plyIndex=Math.max(0, Math.min(ply, activeLine.length));
    applyLineUpTo(plyIndex);
    renderBoard();
    renderCommentAndVariants();
    updateControls();
  }

  function stepNext(){
    if (plyIndex>=activeLine.length){ stop(); return; }
    const nid=activeLine[plyIndex];
    const node=nodeStore.get(nid);
    if (node && node.move) applyMove(node.move);
    plyIndex++;
    renderBoard();
    renderCommentAndVariants();
    updateControls();
  }

  function stepPrev(){
    if (plyIndex<=0) return;
    rebuildTo(plyIndex-1);
  }

  function goFirst(){ stop(); rebuildTo(0); }
  function goLast(){ stop(); rebuildTo(activeLine.length); }

  firstBtn.addEventListener('click', goFirst);
  lastBtn.addEventListener('click', goLast);
  prevBtn.addEventListener('click', ()=>{ stop(); stepPrev(); });
  nextBtn.addEventListener('click', ()=>{ stop(); stepNext(); });

  playBtn.addEventListener('click', ()=>{
    if (timer){ stop(); return; }
    timer=setInterval(()=>{ if (plyIndex>=activeLine.length){ stop(); return; } stepNext(); }, 650);
    playBtn.textContent='⏸';
  });

  backBranchBtn.addEventListener('click', ()=>{
    if (!historyStack.length) return;
    stop();
    const h=historyStack.pop();
    if (h.prevChoice===null) decisions.delete(h.branchPointId);
    else decisions.set(h.branchPointId, h.prevChoice);
    activeLine=buildActiveLine();
    rebuildTo(Math.min(h.plyAtChoice, activeLine.length));
  });

  backMainBtn.addEventListener('click', ()=>{
    if (!historyStack.length) return;
    stop();
    clearDecisions();
    activeLine=buildActiveLine();
    rebuildTo(Math.min(plyIndex, activeLine.length));
  });

  // ============================================================
  //  Variantes + commentaires (style Lidraughts)
  // ============================================================
  function renderCommentAndVariants(){

    const opp = s => (s === 'w' ? 'b' : 'w');
    const sideToMove = (ply) => (ply % 2 === 0 ? startSide : opp(startSide));

    varList.innerHTML = '';

    let bpId = ROOT;

    if (plyIndex === 0){
      bpId = ROOT;
    } else if (plyIndex < activeLine.length){
      const nextId = activeLine[plyIndex];

      const cand1 = nodeStore.get(nextId)?.parentId ?? ROOT;
      const cand2 = nextId;
      const cand3 = activeLine[plyIndex - 1];

      const hasChild = (id) => {
        const n = nodeStore.get(id);
        return n && n.children && n.children.length;
      };

      bpId = hasChild(cand1) ? cand1
           : hasChild(cand2) ? cand2
           : hasChild(cand3) ? cand3
           : cand1;
    } else {
      bpId = activeLine[activeLine.length - 1] ?? ROOT;
    }

    const bp = nodeStore.get(bpId);
    const variants = (bp && bp.children) ? bp.children : [];

    const bpLabel = (bpId === ROOT) ? 'Départ' : (nodeStore.get(bpId)?.move?.raw || 'Position');
    const branchInfo = historyStack.length ? `Choix: ${historyStack.length}` : 'Ligne principale';

    if (crumb){
      crumb.innerHTML =
        `<span class="badge">${branchInfo}</span>` +
        `<span style="margin-left:6px;">Point : ${bpLabel}</span>`;
    }

    // Options = Principale + Variantes
    const options = [];

    // Principale = prochain demi-temps dans la ligne active (si attaché au bp)
    if (plyIndex < activeLine.length){
      const mainFirstId = activeLine[plyIndex];
      const mainNode = nodeStore.get(mainFirstId);

      if (mainNode && (mainNode.parentId === bpId || bpId === ROOT)){
        const mainSecondId = (plyIndex + 1 < activeLine.length) ? activeLine[plyIndex + 1] : null;
        options.push({ label:'Principale', choice:0, firstId:mainFirstId, secondId:mainSecondId });
      }
    }

    // Variantes du bp (ROOT : on ignore children[0] qui est la principale globale)
    const childSeqs = (bpId === ROOT) ? variants.slice(1) : variants;
    childSeqs.forEach((seq, idx)=>{
      if (!seq || !seq.length) return;
      options.push({
        label: `Variante ${idx + 1}`,
        choice: idx + 1,      // 1..n (=> children[choice-1])
        firstId: seq[0],
        secondId: (seq.length > 1) ? seq[1] : null
      });
    });

    // Commentaire "avant exécution" : on affiche trait + coup candidat + commentaire du coup
    const stm = sideToMove(plyIndex);
    const stmTxt = niceSide(stm);

    const chosen = decisions.has(bpId) ? decisions.get(bpId) : 0;
    const activeOpt =
      options.find(o => o.choice === chosen) ||
      options.find(o => o.choice === 0) ||
      options[0] ||
      null;

    if (!activeOpt){
      commentMeta.textContent = `Trait aux ${stmTxt}`;
      commentBox.textContent = '—';
    } else {
      const node = nodeStore.get(activeOpt.firstId);
      const mv = node?.move;
      const comment = (node?.comment || '').trim();
      const annot = mv?.annot || '';
      const annotTxt = annot ? ` — ${annotLabel(annot)}` : '';

      commentMeta.textContent = `Trait aux ${stmTxt} — coup : ${mv?.raw || ''}${annotTxt}`;
      commentBox.textContent = comment || '—';
    }

    // Affichage boutons
    if (!options.length){
      const div = document.createElement('div');
      div.style.fontSize = '13px';
      div.style.opacity = '.8';
      div.textContent = 'Aucune variante à cet endroit.';
      varList.appendChild(div);
      return;
    }

    options.forEach(opt=>{
      const n1 = nodeStore.get(opt.firstId);
      const m1 = n1?.move;
      const ann1 = m1?.annot || '';

      const n2 = opt.secondId ? nodeStore.get(opt.secondId) : null;
      const m2 = n2?.move;

      const chosenNow = decisions.has(bpId) ? decisions.get(bpId) : 0;
      const isActive = (chosenNow === opt.choice) || (!decisions.has(bpId) && opt.choice === 0);

      const btn = document.createElement('button');
      btn.className = 'varBtn';
      btn.type = 'button';

      const line1 = `${isActive ? '✓' : '▶'} ${opt.label} : ${m1?.raw || ''}${ann1 ? ann1 : ''}`;
      const line2 = m2 ? ` • ${m2.raw}` : '';

      btn.innerHTML = `${line1}<small>${line2}</small>`;

      if (isActive){
        btn.style.outline = '2px solid rgba(0,0,0,.18)';
        btn.style.background = '#fff';
      }

      btn.addEventListener('click', ()=>{
        stop();

        const prevChoice = decisions.has(bpId) ? decisions.get(bpId) : null;

        if (opt.choice === 0) decisions.delete(bpId);
        else decisions.set(bpId, opt.choice);

        historyStack.push({ branchPointId: bpId, prevChoice, plyAtChoice: plyIndex });

        activeLine = buildActiveLine();
        rebuildTo(Math.min(plyIndex, activeLine.length)); // rester au branchement
      });

      varList.appendChild(btn);
    });
  }

  // ============================================================
  //  Sélecteur / chargement
  // ============================================================
  function fillSelector(){
    gameSel.innerHTML='';
    for (let i=0;i<allGames.length;i++){
      const g=allGames[i];
      const white=getTag(g,'White');
      const black=getTag(g,'Black');
      const event=getTag(g,'Event');
      const opt=document.createElement('option');
      opt.value=String(i+1);
      const labelPlayers=(white||black)?`${white} / ${black}`:'';
      opt.textContent=[`Partie ${i+1}`,labelPlayers,event].filter(Boolean).join(' — ');
      gameSel.appendChild(opt);
    }
    gameSel.value=String(currentGameIndex);
  }

  function setGame(index, plyToJump){
    stop();
    currentGameIndex=Math.max(1, Math.min(index, allGames.length||1));
    const gameText=allGames[currentGameIndex-1] || allGames[0] || '';

    const st=getStartStateForGame(gameText);
    startSide=st.startSide;
    startPiecesMap=st.startPieces;

    clearDecisions();
    buildTreeFromGame(gameText, startSide);
    activeLine=buildActiveLine();

    fillSelector();
    rebuildTo(plyToJump ?? 0);

    updateScoreLine();
    showError(activeLine.length ? '' : 'PDN chargé, mais aucun coup détecté.');
  }

  gameSel.addEventListener('change', ()=>{
    const v=parseInt(gameSel.value,10);
    if (!Number.isFinite(v)) return;
    setGame(v, 0);
  });

  // ============================================================
  //  URL params ?src=... and #ply
  // ============================================================
  function getQueryParam(name){
    try{ return new URL(location.href).searchParams.get(name); }catch(_e){ return null; }
  }
  function getHashPly(){
    const h=(location.hash||'').replace('#','').trim();
    const n=parseInt(h,10);
    return Number.isFinite(n)&&n>=0?n:null;
  }
  function readEmbeddedPDNById(id){
    if (!id) return '';
    const el=document.getElementById(id);
    return el ? (el.textContent||'').trim() : '';
  }

  function loadFromPDNText(pdnText, plyToJump, gameIndex){
    allGames=splitGames(pdnText||'');
    if (!allGames.length) allGames=[''];
    currentGameIndex=1;
    fillSelector();

    const g = Number.isFinite(gameIndex) ? gameIndex : 1;
    setGame(g, plyToJump ?? 0);
    showError('');
  }

  // ============================================================
  //  Responsive width snap
  // ============================================================
  function snapBoardSize(){
    const max=560;
    const desired=Math.min(window.innerWidth*0.92, max);
    const snapped=Math.max(320, Math.floor(desired/10)*10);
    document.documentElement.style.setProperty('--w', snapped+'px');
  }
  window.addEventListener('resize', snapBoardSize);
  setTimeout(snapBoardSize,0);
  setTimeout(snapBoardSize,200);

  // ============================================================
  //  Init
  // ============================================================
  const std=new Map();
  for (let n=31;n<=50;n++) std.set(n,{color:'w',king:false});
  for (let n=1;n<=20;n++)  std.set(n,{color:'b',king:false});
  startSide='w';
  startPiecesMap=std;
  setPiecesFromMap(startPiecesMap);

  resetTree();
  activeLine=[];
  plyIndex=0;
  renderBoard();
  renderCommentAndVariants();
  updateControls();
  showError('En attente du PDN…');

  try{ window.parent.postMessage({type:'OPL_READY'}, '*'); }catch(_e){}

  const src=getQueryParam('src') || 'opl-pdn';
  const embedded=readEmbeddedPDNById(src);
  if (embedded){
    const ply=getHashPly() ?? 0;
    loadFromPDNText(embedded, ply, 1);
  }

  window.addEventListener('message', (e)=>{
    if (!e || !e.data) return;
    if (e.data.type==='OPL_PDN'){
      const pdn=(typeof e.data.pdn==='string')?e.data.pdn:'';
      if (!pdn.trim()) return;
      const ply=parseInt(e.data.ply,10);
      const plyToJump=Number.isFinite(ply)?ply:0;
      const game=parseInt(e.data.game,10);
      const gameIndex=Number.isFinite(game)?game:1;
      stop();
      loadFromPDNText(pdn, plyToJump, gameIndex);
    }
    if (e.data.type==='OPL_GOTO'){
      const ply=parseInt(e.data.ply,10);
      if (!Number.isFinite(ply)) return;
      stop();
      rebuildTo(ply);
    }
  });

})();
</script>
</body>
</html>
